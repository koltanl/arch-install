#!/usr/bin/env python3
import os
from pathlib import Path
import argparse
from datetime import datetime
import sys

def generate_tree(directory, output_file, prefix="", exclude_dirs=None):
    """
    Recursively generate a tree structure of the given directory
    """
    if exclude_dirs is None:
        exclude_dirs = {'.git', '__pycache__', 'node_modules', '.venv', 'venv'}
    
    try:
        # Convert to Path object if it isn't already
        directory = Path(directory)
        # Get and sort directory contents
        items = sorted(list(directory.iterdir()))
        
        # Process each item
        for index, item in enumerate(items):
            # Skip excluded directories
            if item.name in exclude_dirs or item.name.startswith('.'):
                continue
            
            is_last = index == len([i for i in items if i.name not in exclude_dirs])
            current_prefix = "└── " if is_last else "├── "
            
            # Write the current item
            output_file.write(f"{prefix}{current_prefix}{item.name}\n")
            
            # Recursively process directories
            if item.is_dir():
                new_prefix = prefix + ("    " if is_last else "│   ")
                generate_tree(item, output_file, new_prefix, exclude_dirs)
                
    except PermissionError:
        output_file.write(f"{prefix}!-- Permission denied: {directory} --!\n")
    except Exception as e:
        output_file.write(f"{prefix}!-- Error: {str(e)} --!\n")

def main():
    parser = argparse.ArgumentParser(description='Generate a tree structure of directories and files')
    parser.add_argument('source', nargs='?', default='.',
                      help='Source directory to generate tree from (default: current directory)')
    parser.add_argument('-o', '--output', 
                      help='Output file (default: tree_<timestamp>.txt in source directory)')
    parser.add_argument('-e', '--exclude', nargs='+',
                      help='Additional directories to exclude')
    parser.add_argument('-v', '--verbose', action='store_true',
                      help='Enable verbose output')
    
    args = parser.parse_args()
    
    # Enable verbose output
    if args.verbose:
        print(f"Processing directory: {args.source}")
    
    try:
        # Convert source to absolute Path
        source_path = Path(args.source).resolve()
        
        if args.verbose:
            print(f"Resolved path: {source_path}")
        
        # Verify source directory exists
        if not source_path.exists():
            print(f"Error: Directory '{source_path}' does not exist", file=sys.stderr)
            return 1
        
        if not source_path.is_dir():
            print(f"Error: '{source_path}' is not a directory", file=sys.stderr)
            return 1
        
        # Set up excluded directories
        exclude_dirs = {'.git', '__pycache__', 'node_modules', '.venv', 'venv'}
        if args.exclude:
            exclude_dirs.update(args.exclude)
        
        # Determine output file
        if args.output:
            output_path = Path(args.output).resolve()
        else:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_path = source_path / f"tree_{timestamp}.txt"
        
        if args.verbose:
            print(f"Writing to: {output_path}")
        
        # Create parent directories if they don't exist
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Generate the tree
        with open(output_path, 'w') as f:
            # Write header
            f.write(f"Directory Tree for: {source_path}\n")
            f.write(f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("=" * 50 + "\n\n")
            
            # Write the tree structure
            f.write(f"{source_path.name}\n")
            generate_tree(source_path, f)
            
            # Write footer
            f.write("\n" + "=" * 50 + "\n")
            f.write("Generated by treegen.py\n")
        
        print(f"Tree structure has been written to: {output_path}")
        return 0
        
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1

if __name__ == "__main__":
    sys.exit(main()) 